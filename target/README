I used AI to make my readme look nice.
Event Planner Project

Data Structures Used

1. GuestListManager
Structures: LinkedList, Map<String, Guest>
Reasoning:

LinkedList allows efficient additions.

Map enables O(1) guest lookup by key (Name-GroupTag).

2. VenueSelector
Structure: List<Venue>
Reasoning:

Maintains a collection of venues for easy iteration when selecting the best fit.

3. SeatingPlanner
Structures: Map<String, Queue<Guest>>, Queue, Map<Integer, List<Guest>>
Reasoning:

Groups guests by groupTag using Map + Queue.

Seats guests fairly in a Queue.

Maps table numbers to seated guests for organization, allows allows quick access.

4. TaskManager
: uses a Deque<Task> for upcoming tasks and a Stack<Task> for completed tasks.

Queue enforces execution order (FIFO).

Stack allows efficient undo of the last executed task (LIFO).

Algorithms Used

GuestListManager:

Map lookup: Find a guest in O(1) time by key.

VenueSelector:

Linear search: Selects the cheapest venue within budget and capacity constraints.

TaskManager:

Queue & Stack operations:

Execute tasks in FIFO order.

Undo tasks in LIFO order.

Big-O Complexity
Operation	Complexity	Notes
Finding a guest	O(1)	Using Map
Selecting a venue	O(n)	Linear search through the venue list
Generating seating	O(g + t)	g = total guests, t = total tables; time grows roughly linearly with guests and tables
Executing a task	O(1)	Queue operation
Undoing a task	O(1)	Stack operation