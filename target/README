Event Planner Project

I used AI to make my README look nice.

Project Overview

The Event Planner Project is designed to simplify event management, from guest tracking to seating arrangements and task management. This project leverages efficient data structures and algorithms to handle guests, venues, seating, and tasks in a structured and performant manner.

Whether youâ€™re planning a small party or a large conference, this system ensures optimal organization with minimal manual effort.

Key Features

Guest Management: Fast addition, removal, and lookup of guests.

Venue Selection: Easily choose the best venue based on budget and capacity.

Seating Planning: Fair and orderly table assignments based on guest groups.

Task Management: Efficiently track upcoming tasks and undo completed ones.

Performance Optimized: Carefully chosen data structures and algorithms ensure fast operations.

Data Structures

GuestListManager

Structures: LinkedList<Guest> + Map<String, Guest>

Reasoning:

LinkedList allows O(1) additions/removals at the ends and makes grouping guests by tag efficient.

Map allows O(1) lookup by key = name-groupTag and keeps entries sorted.

Together, they provide fast management for both iteration and search.

VenueSelector

Structure: List<Venue>

Reasoning:

Maintains all venue options.

Linear search is sufficient because the number of venues is small.

Easy iteration to select the cheapest venue within budget and capacity.

SeatingPlanner

Structures: Map<String, Queue<Guest>>, Map<Integer, List<Guest>>

Reasoning:

Map<String, Queue<Guest>> groups guests by groupTag for fair seating and quick lookup.

Queue ensures FIFO seating order within each group.

Map<Integer, List<Guest>> maps table numbers to seated guests for instant access.

TaskManager

Structures: Deque<Task> for upcoming tasks, Stack<Task> for completed tasks

Reasoning:

Deque ensures FIFO order for task execution.

Stack allows LIFO undo for last completed task.

Algorithms & Big-O Analysis
Operation	Complexity	Notes
Add guest	O(1)	Map insertion allows optimal lookup and addition
Lookup guest	O(1)	Map key enables fast retrieval
Remove guest	O(1)	Map removal is efficient
Select venue	O(n)	Linear search through list of venues
Generate seating	O(g + t)	g = total guests, t = total tables; each guest assigned to a table
Add task	O(1)	Insertion at front/back of Deque
Execute next task	O(1)	Poll from front of Deque
Undo last task	O(1)	Pop from Stack and reinsert into Deque

Sorting Algorithm:
Sorting is not required at the end, as per project requirements and class discussion. The chosen data structures ensure logical ordering without additional sorting overhead.

How It Works

Add Guests: Guests are added to GuestListManager for quick lookup and flexible iteration.

Select Venue: VenueSelector evaluates all venues and picks the best fit.

Assign Seating: SeatingPlanner uses FIFO queues to assign guests to tables fairly.

Manage Tasks: TaskManager tracks upcoming tasks and supports undoing completed ones.